<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Stryke Force">
  <title>Swerve Drive</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../static/reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../static/reveal.js/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="../static/reveal.js/dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="../static/css/classroom.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide" data-background-color="rgb(241, 186, 27)">
  <h1 class="title">Swerve Drive</h1>
  <p class="author">Stryke Force</p>
</section>

<section>
<section id="swerve-drive-introduction" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Drive Introduction</h1>

</section>
<section id="mechanical-design" class="slide level2">
<h2>Mechanical Design</h2>
<ul>
<li>Motors &amp; Controllers</li>
<li>Drive</li>
<li>Azimuth - turns</li>
</ul>
<p>Put a picture here.</p>
</section>
<section id="swerve-operation" class="slide level2">
<h2>Swerve Operation</h2>
<ul>
<li>Forward / Back</li>
<li>Strafe Left / Right</li>
</ul>
</section>
<section id="swerve-control-systems" class="slide level2">
<h2>Swerve Control Systems</h2>
<ul>
<li>Azimuth closed-loop</li>
<li>Drive open-loop</li>
<li>Drive closed-loop</li>
</ul>
</section></section>
<section>
<section id="swerve-drive-motion" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Drive Motion</h1>
<p>To move the swerve drive, we need to convert the desired motion of the robot into positions and speeds of each of the four swerve wheels.</p>
</section>
<section id="swerve-motion" class="slide level2">
<h2>Swerve Motion</h2>
<p>There are three components to swerve drive motion.</p>
<ul>
<li><strong>Forward</strong> and backwards</li>
<li><strong>Strafe</strong> left and right</li>
<li><strong>Yaw</strong> counter-clockwise and clockwise</li>
</ul>
<p><img data-src="img/swerve-math/directions.svg" alt="swerve directions" /><br />
</p>
<p>The red arrows indicate the <strong>speed</strong> and <strong>direction</strong> each wheel is pushing.</p>
<p>We call this the <strong>velocity vector</strong> of the wheel.</p>
</section>
<section id="swerve-motion-1" class="slide level2">
<h2>Swerve Motion</h2>
<p>These separate components can be combined together to move the robot in any direction.</p>
<p><img data-src="img/swerve-math/forward+strafe.svg" alt="forward+strafe" /><br />
</p>
<p>In this example, equal amounts of <strong>forward</strong> and <strong>strafe</strong> input drive the robot at 45° across the field.</p>
</section>
<section id="swerve-motion-2" class="slide level2">
<h2>Swerve Motion</h2>
<p>All three components can be combined together to produce complex motion.</p>
<p><img data-src="img/swerve-math/forward+strafe+yaw.svg" alt="forward+strafe" /><br />
</p>
<p>In this example, equal amounts of <strong>forward</strong>, <strong>strafe</strong> and <strong>yaw</strong> input drive the robot across the field while yawing.</p>
</section>
<section id="swerve-yaw-component" class="slide level2">
<h2>Swerve Yaw Component</h2>
<p>When the robot yaws, the wheels are positioned perpendicular to the center of rotation.</p>
<p>Note that this is not 45° if the robot isn’t square.</p>
<p><img data-src="img/swerve-math/frame-aspect.svg" alt="frame aspect ration" /><br />
</p>
<p>We can also yaw around an arbitrary off-center point relative to the robot.</p>
</section></section>
<section>
<section id="swerve-math" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Math</h1>
<p>We can calculate desired position and speed of each wheel using vectors.</p>
</section>
<section id="vectors" class="slide level2">
<h2>Vectors</h2>
<p>We use <strong>vectors</strong> to represent velocity, which is speed and direction.</p>
<p><img data-src="img/swerve-math/vectors.svg" alt="vectors" /><br />
</p>
<p>Here we show how to add two vectors together, later we will show rotating a vector by a given angle.</p>
</section>
<section id="coordinate-system" class="slide level2">
<h2>Coordinate System</h2>
<p>We work in two coordinate frames, one local to the robot and one global for the field.</p>
<p>Going forward, we’ll also refer to swerve drive motion components (forward, strafe, yaw) as chassis speed (<strong>v<sub>x</sub></strong>, <strong>v<sub>y</sub></strong>, and <strong>ω</strong>), with respect to the robot frame of reference.</p>
<p><img data-src="img/swerve-math/coordinate-frames.svg" alt="coordinate frames" /><br />
</p>
</section>
<section id="wheel-position-and-speed" class="slide level2">
<h2>Wheel Position and Speed</h2>
<p>We add together the desired robot-oriented velocity inputs to get a velocity vector for each wheel.</p>
<p><img data-src="img/swerve-math/wheel-vectors.svg" alt="coordinate frames" /><br />
</p>
</section>
<section id="wheel-speed-and-azimuth" class="slide level2">
<h2>Wheel Speed and Azimuth</h2>
<p>Each wheel’s <strong>speed</strong> and <strong>azimuth</strong> can be calculated from its velocity vector (<strong>v</strong><sub>w</sub>).</p>
<p><img data-src="img/swerve-math/wheel-position+speed.svg" alt="wheel position + speed" /><br />
</p>
<p><strong>Azimuth</strong> (θ) is the term we use for the wheel’s angle relative to the robot frame of reference.</p>
</section>
<section id="normalize-wheel-speeds" class="slide level2">
<h2>Normalize Wheel Speeds</h2>
<p>Sometimes after calculating wheel velocity vectors, the requested speed may be above the maximum attainable speed for the drive motor on that swerve module.</p>
<p>To fix this issue, we “normalize” all the wheel speeds to make sure that all requested module speeds are below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<p><br />
</p>
<table>
<thead>
<tr class="header">
<th>Wheel</th>
<th style="text-align: right;">Calculated Speed</th>
<th style="text-align: right;">Normalized Speed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LF</td>
<td style="text-align: right;">2.414</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td>RF</td>
<td style="text-align: right;">1.732</td>
<td style="text-align: right;">0.717</td>
</tr>
<tr class="odd">
<td>LR</td>
<td style="text-align: right;">1.732</td>
<td style="text-align: right;">0.717</td>
</tr>
<tr class="even">
<td>RR</td>
<td style="text-align: right;">0.414</td>
<td style="text-align: right;">0.172</td>
</tr>
</tbody>
</table>
</section>
<section id="optimize-wheel-position" class="slide level2">
<h2>Optimize Wheel Position</h2>
<p>We minimize the change in heading the desired swerve wheel direction would require by potentially reversing the direction the wheel spins.</p>
<p>When optimized, the furthest a wheel will ever rotate is 90 degrees.</p>
<div class="columns">
<div class="column" style="display:inline-flex; flex-direction: column; justify-content: center; height: 766px">
<p>If the difference between your desired and current azimuth is greater than 90°, rotate the desired azimuth by 180° and reverse the drive motor.</p>
</div><div class="column" style="width:50%;">
<p><img data-src="img/swerve-math/optimized-azimuth.svg" alt="optimize azimuth" /><br />
</p>
</div>
</div>
</section>
<section id="field-oriented-driving" class="slide level2">
<h2>Field Oriented Driving</h2>
<p>In Teleoperation, we normally provide driver joystick (velocity) inputs relative to the field frame of reference.</p>
<p>We rotate the requested field-oriented robot velocity vector by an amount equal to the gyro angle, θ, to get the desired robot-oriented velocity vector.</p>
<p><img data-src="img/swerve-math/field-oriented.svg" alt="optimize azimuth" /><br />
</p>
<p>In this example, pushing the <strong>v</strong><sub>x</sub> (F/R) joystick in the postive x direction will move the robot directly down the field, no matter the direction the robot is facing (θ).</p>
</section></section>
<section>
<section id="swerve-software" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Software</h1>
<p>In our robot, we use the WPILIB kinematics suite to convert<br />
desired velocities to swerve module speed and angle.</p>
</section>
<section id="terminology" class="slide level2">
<h2>Terminology</h2>
<dl>
<dt>Kinematics</dt>
<dd><p>The kinematics classes help convert between a universal <code>ChassisSpeeds</code> object, containing linear and angular velocities for a robot to usable speeds for each individual module states (speed and angle) for a swerve drive.</p>
</dd>
<dt>Odometry</dt>
<dd><p>Odometry uses sensors on the robot to create an estimate of the position of the robot on the field. In our robots, these sensors are typically drive and azimuth encoders and a gyroscope to measure robot angle.</p>
</dd>
<dd><p>The odometry classes utilize the kinematics classes along with periodic inputs about speeds and angles to create an estimate of the robot’s location on the field.</p>
</dd>
<dt>Pose</dt>
<dd><p>A robot’s pose is the combination of it’s X, Y, and angle (θ) with respect to the field.</p>
</dd>
</dl>
</section>
<section id="the-chassisspeeds-class" class="slide level2">
<h2>the <code>ChassisSpeeds</code> Class</h2>
<p>The <code>ChassisSpeeds</code> class represents the speeds of a robot chassis.</p>
<dl>
<dt><code>vx</code></dt>
<dd>The velocity of the robot in the <strong>x</strong> (forward) direction.
</dd>
<dt><code>vy</code></dt>
<dd>The velocity of the robot in the <strong>y</strong> (strafe) direction.<br />
Positive values mean the robot is moving to the left.
</dd>
<dt><code>omega</code></dt>
<dd>The angular velocity of the robot in radians per second.<br />
Positive is CCW rotation (yaw) of the robot.
</dd>
</dl>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> xSpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ySpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> rotSpeed <span class="op">=</span> rightJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxRadiansPerSec<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">);</span></span></code></pre></div>
<p>Speeds are aligned to a <a href="#/coordinate-system">coordinate system</a> and are given in meters per second.</p>
</section>
<section class="slide level2">

<p>We also use the <code>ChassisSpeeds</code> to convert <a href="#/field-oriented-driving">field-relative</a> speeds into robot-relative speeds.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> xSpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ySpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> rotSpeed <span class="op">=</span> rightJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxRadiansPerSec<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> ChassisSpeeds<span class="op">.</span><span class="fu">fromFieldRelativeSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">,</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">());</span></span></code></pre></div>
<p>The angle of the robot is measured by a gyroscope. The robot’s angle is considered to be zero when it is facing directly away from our alliance station wall.</p>
</section>
<section id="the-swervedrivekinematics-class" class="slide level2">
<h2>The <code>SwerveDriveKinematics</code> Class</h2>
<p>The <code>SwerveDriveKinematics</code> class is a helper class that converts a chassis velocity (<strong>v</strong><sub>x</sub>, <strong>v</strong><sub>y</sub>, and <strong>ω</strong> components) into individual module states (speed and angle).</p>
<p>We initialize an instance of this class by passing in four wheel locations, in meters, relative to the center of the robot.</p>
<div class="columns">
<div class="column" style="width:75%;">
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>var frontLeft <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>var frontRight <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>var rearLeft <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(-</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>var rearRight <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(-</span><span class="fl">0.3</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>var kinematics <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveKinematics</span><span class="op">(</span>frontLeft<span class="op">,</span> frontRight<span class="op">,</span> rearLeft<span class="op">,</span> rearRight<span class="op">);</span></span></code></pre></div>
</div><div class="column" style="width:25%;">
<p><img data-src="img/swerve-software/wheel-locations.svg" style="width:65.0%" alt="wheel locations" /><br />
</p>
</div>
</div>
</section>
<section class="slide level2">

<p>We then use this <code>kinematics</code> instance to perform <em>inverse kinematics</em> to return the module states from a desired chassis velocity.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>var speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">);</span></span></code></pre></div>
<p>The returned module states are an array of four <code>SwerveModuleState</code> objects, each containing the speed and angle of one of the wheels. They are passed back in the same wheel order that we initialized the <code>SwerveDriveKinematics</code> in.</p>
<p><br />
</p>
<p>If you want to specify a <a href="#/swerve-yaw-component">variable center of rotation</a> for the robot, you can pass in a optional <code>Translation2d</code> object that is the desired center.</p>
<p>For example, you want to yaw the robot underneath the shooter that is 10 cm left of the centerline of the robot.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>var speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> rotSpeed<span class="op">);</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>var center <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span></code></pre></div>
</section>
<section class="slide level2">

<p>Sometimes after calculating wheel velocity vectors, the requested speed may be above the maximum attainable speed for the swerve module drive motor and need to be <a href="#/normalize-wheel-speeds">normalized</a>.</p>
<p>To fix this issue, <code>SwerveDriveKinematics</code> has a <code>normalizeWheelSpeeds​</code> static method.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>SwerveDriveKinematics<span class="op">.</span><span class="fu">normalizeWheelSpeeds</span><span class="op">(</span>states<span class="op">,</span> kMaxMetersPerSec<span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">// all state speeds are now less than or equal to kMaxMetersPerSec...</span></span></code></pre></div>
<p>We can also use this <code>kinematics</code> instance to perform <em>foward kinematics</em> to return the instantaneous chassis velocity from module states.</p>
<p>Typically we would query the hardware encoders to get actual module states, as in this example.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// driveSubsystem has code to read swerve module hardware encoders and converts to module states</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> driveSubsystem<span class="op">.</span><span class="fu">getModuleStates</span><span class="op">();</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toChassisSpeeds</span><span class="op">(</span>states<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;robot vxMetersPerSecond = </span><span class="sc">%f</span><span class="st">, vyMetersPerSecond = </span><span class="sc">%f</span><span class="st">, omegaRadiansPerSecond = </span><span class="sc">%f</span><span class="st"> </span><span class="sc">%n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">vxMetersPerSecond</span><span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">vyMetersPerSecond</span><span class="op">,</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">omegaRadiansPerSecond</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
</section>
<section id="the-swervemodulestate-class" class="slide level2">
<h2>The <code>SwerveModuleState</code> Class</h2>
<p>The <code>SwerveModuleState</code> is a simple data class that represents the speed and direction of a swerve module.</p>
<p>We would typically pass it to our own <code>SwerveModule</code> class that knows about our specific hardware.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> SwerveDriveKinematics<span class="op">.</span><span class="fu">normalizeWheelSpeeds</span><span class="op">(</span>states<span class="op">,</span> kMaxMetersPerSec<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>frontLeftModule<span class="op">.</span><span class="fu">setDesiredState</span><span class="op">(</span>states<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">// rest of modules...</span></span></code></pre></div>
<p>It also performs the <a href="#/optimize-wheel-position">optimization of wheel positioning</a> by minimizing the change in heading the desired swerve wheel direction would require by potentially reversing the direction the wheel spins. For example, our <code>SwerveModule</code> class could use it in its <code>setDesiredState</code> method.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">setDesiredState</span><span class="op">(</span>SwerveModuleState desiredState<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    SwerveModuleState state <span class="op">=</span> SwerveModuleState<span class="op">.</span><span class="fu">optimize</span><span class="op">(</span>desiredState<span class="op">,</span> <span class="kw">new</span> <span class="fu">Rotation2d</span><span class="op">(</span>azimuth<span class="op">.</span><span class="fu">getEncoderValue</span><span class="op">()));</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use optimized state to set module speed and angle...</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="the-swervedriveodometry-class" class="slide level2">
<h2>The <code>SwerveDriveOdometry</code> Class</h2>
<p>Odometry allows us to track our robot’s position on the field over a course of a match using readings from swerve drive encoders and swerve azimuth encoders.</p>
<p>We initialize an instance of this class by passing in our initialized <code>SwerveDriveKinimatics</code> object, the robot’s gyro angle, and optionally a starting robot pose.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>var kinematics <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveKinematics</span><span class="op">(</span>frontLeft<span class="op">,</span> frontRight<span class="op">,</span> rearLeft<span class="op">,</span> rearRight<span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>var theta <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>var odometry <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveOdometry</span><span class="op">(</span>kinematics<span class="op">,</span> theta<span class="op">);</span></span></code></pre></div>
<p>Periodically (for example, in <code>Subsystem.periodic()</code>), we update the odometry with the current gyro angle and swerve module states.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">periodic</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    var theta <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> <span class="fu">getModuleStates</span><span class="op">();</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    odometry<span class="op">.</span><span class="fu">update</span><span class="op">(</span>theta<span class="op">,</span> states<span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section class="slide level2">

<p>We can perform a “hard” reset of the odometry position if we are in possession of a known robot position. For example, perhaps we have just driven the robot into some sort of game feature like a docking port.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Pose2d pose <span class="op">=</span> Constants<span class="op">.</span><span class="fu">DOCKING_POSE</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>var gyroAngle <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>odometry<span class="op">.</span><span class="fu">resetPosition</span><span class="op">(</span>pose<span class="op">,</span> gyroAngle<span class="op">);</span></span></code></pre></div>
<p>By passing in the gyro angle, odometry will compensate for any gyro drift that has occurred up to this point.</p>
<p><br />
</p>
<p>Finally, we can ask odometry for the robot’s calculated field position and angle. This returns the pose of the robot as of the last call to <code>update()</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Pose2d pose <span class="op">=</span> odometry<span class="op">.</span><span class="fu">getPoseMeters</span><span class="op">();</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;robot x = </span><span class="sc">%f</span><span class="st"> meters, y = </span><span class="sc">%f</span><span class="st"> meters, theta = </span><span class="sc">%f</span><span class="st"> degrees </span><span class="sc">%n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getX</span><span class="op">(),</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getY</span><span class="op">(),</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getRotation</span><span class="op">().</span><span class="fu">getDegrees</span><span class="op">()</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>We can use odometry during the autonomous period for complex tasks like path following. Furthermore, odometry can be used for latency compensation when using computer-vision systems.</p>
</section>
<section id="swerve-kinematics-examples" class="slide level2">
<h2>Swerve Kinematics Examples</h2>
<p>We can use the Python version of WPILIB kinematics classes in a Jupyter notebook to easily convert desired robot speed and rotation into swerve wheel speeds and angles.</p>
<p>The classes and concepts are identical to the Java version we use on the robot.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># define some useful constants</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>MAX_SPEED <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>MAX_ROTATION <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> math.pi</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># set up the swerve drive kinematics class by specifying where the wheels are</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># relative to the center of the robot</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fl_loc <span class="op">=</span> Translation2d(<span class="fl">0.3</span>, <span class="fl">0.3</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fr_loc <span class="op">=</span> Translation2d(<span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.3</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>rl_loc <span class="op">=</span> Translation2d(<span class="op">-</span><span class="fl">0.3</span>, <span class="fl">0.3</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>rr_loc <span class="op">=</span> Translation2d(<span class="op">-</span><span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.3</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>kinematics <span class="op">=</span> SwerveDrive4Kinematics(fl_loc, fr_loc, rl_loc, rr_loc)</span></code></pre></div>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-direction">Drive in forward direction</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-01.svg" style="width:60.0%" alt="swerve 01" /><br />
</p>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-right-directions">Drive in forward, right directions</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="op">-</span>MAX_SPEED, <span class="dv">0</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-02.svg" style="width:60.0%" alt="swerve 02" /><br />
</p>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-right-and-clockwise-directions">Drive in forward, right and clockwise directions</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="op">-</span>MAX_SPEED, <span class="op">-</span>MAX_ROTATION)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-03.svg" style="width:60.0%" alt="swerve 03" /><br />
</p>
</section></section>
<section>
<section id="trajectory-following" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Trajectory Following</h1>
<p>Getting the robot from point A to point B autonomously.</p>
</section>
<section id="why-trajectory-following" class="slide level2">
<h2>Why Trajectory Following?</h2>
<p>FRC® games often feature autonomous tasks that require a robot to effectively and accurately move from a known starting location to a known scoring location.</p>
<p>During the 2018 season, Stryke Force changed from the “drive-turn-drive” method to trajectory following.</p>
<p><img data-src="img/swerve-paths/why-trajectory.svg" alt="why trajectory" /><br />
</p>
<p>While more technically challenging, trajectories can be driven much faster since we don’t have to stop to change direction.</p>
</section>
<section id="terminology-1" class="slide level2">
<h2>Terminology</h2>
<dl>
<dt>JSON</dt>
<dd><p>Used for PathWeaver <a href="#/pathweaver-trajectory-json">trajectory export</a>, JavaScript Object Notation, is an open standard file format, and data interchange format, that uses human-readable text to store and transmit data objects.</p>
</dd>
<dt>Pose</dt>
<dd><p>A robot’s pose is the combination of it’s X, Y, and angle (θ) with respect to the field. See the <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/geometry/Pose2d.html"><code>Pose2d</code></a> class.</p>
</dd>
<dt>Trajectory</dt>
<dd><p>A trajectory contains of a collection of <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/trajectory/Trajectory.State.html"><code>State</code></a> points that represent the pose, curvature, time elapsed, velocity, and acceleration at that point. See the <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/trajectory/Trajectory.html"><code>Trajectory</code></a> class.</p>
</dd>
<dt>Waypoint</dt>
<dd><p>Waypoints consists of a X, Y position on the field as well as a robot heading described by a tangent line.</p>
</dd>
</dl>
<aside class="notes">
<ul>
<li>Difference between pose and waypoint angle? Pose is robot yaw, waypoint is direction of travel.</li>
</ul>
</aside>
</section>
<section id="starting-a-pathweaver-project" class="slide level2">
<h2>Starting a PathWeaver Project</h2>
<p>When starting a new PathWeaver project, we need to provide season-specific information.</p>
<p><img data-src="img/pathweaver/pathweaver_project.png" style="width:60.0%" alt="PathWeaver" /><br />
</p>
<p>Team up with a mentor to set this up for the first time in a season.</p>
</section>
<section id="creating-a-trajectory" class="slide level2">
<h2>Creating a Trajectory</h2>
<p>The preferred way to create and visualize a path is with the PathWeaver tool.</p>
<p><img data-src="img/pathweaver/pathweaver_ui.png" alt="PathWeaver" /><br />
</p>
</section>
<section id="pathweaver-tips-and-tricks" class="slide level2">
<h2>PathWeaver Tips and Tricks</h2>
<ul>
<li>Adding additional waypoints and changing their tangent vectors can affect the path that is followed. Additional waypoints can be added by dragging in the middle of the path.</li>
<li>Fewer is usually better when it comes to waypoints.</li>
<li>It’s sometimes hard to precisely set where the waypoints should be placed. In this case, setting the waypoint locations can be done by entering the X and Y value after selecting the waypoint.</li>
<li>Path Groups are a way of visualizing where one path ends and the next one starts. By adding all the paths to a single path group and selecting the group, all paths in that group will be shown. Each path can be edited while viewing all the paths.</li>
</ul>
</section>
<section id="deploy-pathweaver-json-to-robot" class="slide level2">
<h2>Deploy PathWeaver JSON to Robot</h2>
<p>Build all paths in the project by clicking the <strong>Build Paths</strong> button.</p>
<p>Configure PathWeaver to output JSON files in <strong><code>src/main/deploy/paths</code></strong>. Deploying robot code automatically places JSON files on the roboRIO file system in <strong><code>/home/lvuser/deploy/paths/output</code></strong>.</p>
<p>The PathWeaver JSON can be accessed using <code>getDeployDirectory</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> trajectoryJson <span class="op">=</span> <span class="st">&quot;paths/output/YourPath.wpilib.json&quot;</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>Path trajectoryPath <span class="op">=</span> Filesystem<span class="op">.</span><span class="fu">getDeployDirectory</span><span class="op">().</span><span class="fu">toPath</span><span class="op">().</span><span class="fu">resolve</span><span class="op">(</span>trajectoryJson<span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>Trajectory trajectory <span class="op">=</span> TrajectoryUtil<span class="op">.</span><span class="fu">fromPathweaverJson</span><span class="op">(</span>trajectoryPath<span class="op">);</span></span></code></pre></div>
<p><br />
</p>
<p><strong>Note:</strong> Currently PathWeaver displays the <a href="#/coordinate-system">coordinate system</a> origin at the top left of the field. When building paths, PathWeaver sets the origin at the bottom left in order to be compatible with the <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/smartdashboard/Field2d.html"><code>Field2d</code></a> view in the simulator GUI.</p>
<aside class="notes">
<p>Editing the initial waypoint of a path to have X=0.0 and Y=-8.21055 (~27 ft) will build the path with the initial state translation at X=0.0 and Y=0.0.</p>
</aside>
</section>
<section id="robot-checklist" class="slide level2">
<h2>Robot Checklist</h2>
<p>There are a few things the robot needs before we can actually drive a trajectory.</p>
<p><br />
</p>
<ol type="1">
<li>Swerve modules and motor controllers configured.
<ul>
<li>Motor controllers settings.</li>
<li>Azimuth motor closed-loop tuning.</li>
<li>Determine the maximum attainable speed for the robot.</li>
<li>Measure drive encoder “distance per pulse”.</li>
</ul></li>
<li>Driver joystick inputs configured.</li>
<li>Finish setting up the swerve drive and verify teleop driving. See <a href="#/the-swervedrivekinematics-class"><code>SwerveDriveKinematics</code></a>.</li>
<li>Determine swerve module drive closed-loop velocity tuning.</li>
<li>Configure <a href="#/the-swervedriveodometry-class"><code>SwerveDriveOdometry</code></a>.</li>
<li>Configure the <code>HolonomicDriveController</code>. We’ll see this in a later slide.</li>
</ol>
<aside class="notes">
<p>Note that for the WPILib Encoder class, “pulse” refers to a full encoder cycle (i.e. four edges)</p>
</aside>
</section>
<section id="the-holonomicdrivecontroller-class" class="slide level2">
<h2>The HolonomicDriveController Class</h2>
<p>The <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/controller/HolonomicDriveController.html"><code>HolonomicDriveController</code></a> is used to follow trajectories using a <em>holonomic</em> drive train, such as a swerve or mecanum drive.</p>
<p>The holonomic drive controller takes in one PID controller for each direction, forward and strafe, and one profiled PID controller for the yaw.</p>
<p>Because the yaw dynamics are decoupled from translations, we can can specify a custom yaw heading that the robot should point toward. This heading reference is profiled for smoothness to accomodate yaw setpoint changes.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>var xController <span class="op">=</span> <span class="kw">new</span> <span class="fu">PIDController</span><span class="op">(</span>kPx<span class="op">,</span> kIx<span class="op">,</span> kDx<span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>var yController <span class="op">=</span> <span class="kw">new</span> <span class="fu">PIDController</span><span class="op">(</span>kPy<span class="op">,</span> kIy<span class="op">,</span> kDy<span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>var thetaController <span class="op">=</span> <span class="kw">new</span> <span class="fu">ProfiledPIDController</span><span class="op">(</span>kPt<span class="op">,</span> kIt<span class="op">,</span> kDt<span class="op">,</span> constraints<span class="op">);</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>var holonomicDriveController <span class="op">=</span> <span class="kw">new</span> HolonomicDriveController​<span class="op">(</span>xController yController<span class="op">,</span> thetaController<span class="op">);</span></span></code></pre></div>
</section>
<section id="using-constraints" class="slide level2">
<h2>Using Constraints</h2>
<ul>
<li>optional</li>
</ul>
</section>
<section id="wpilib" class="slide level2">
<h2>WPILIB</h2>
</section></section>
<section id="the-end" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">The End</h1>
<p><img data-src="img/kings.jpg" style="width: 50%; margin-top:50px; box-shadow: 7px 7px 7px rgba(0, 0, 0, 0.4);" alt="Eat like Kings" /><br />
</p>
<aside class="notes">
<p>Trivia: Mark quoted from this cartoon after seeing the first trajectory following demo in 2018.</p>
</aside>
</section>

<section id="appendix" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Appendix</h1>

</section>

<section>
<section id="pathweaver-deep-dive" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">PathWeaver Deep Dive</h1>
<p>An exploration of how PathWeaver interfaces with WPILIB Trajectory classes.</p>
</section>
<section id="pathweaver-path" class="slide level2">
<h2>PathWeaver Path</h2>
<p>We can use PathWeaver to create a trajectory for the robot to drive.</p>
<p><br />
</p>
<p><img data-src="img/pathweaver/pathweaver_screenshot.png" alt="pathweaver screenshot" /><br />
</p>
</section>
<section id="pathweaver-path-1" class="slide level2">
<h2>PathWeaver Path</h2>
<p>PathwWaver internally represents this path as a list of <strong>waypoints</strong>.</p>
<p><br />
</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">X</th>
<th style="text-align: right;">Y</th>
<th style="text-align: right;">Tangent X</th>
<th style="text-align: right;">Tangent Y</th>
<th style="text-align: center;">Fixed Theta</th>
<th style="text-align: center;">Reversed</th>
<th style="text-align: left;">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">-2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">start</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">top internal</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">-3</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">bottom internal</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">-2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">end</td>
</tr>
</tbody>
</table>
<p><br />
</p>
<p>They are saved as CSV-formatted data in <code>*.path</code> files in a PathWeaver project.</p>
</section>
<section id="pathweaver-waypoints" class="slide level2">
<h2>PathWeaver Waypoints</h2>
<p>The important parts of a waypoint are its coordinates and the length and direction of its <strong>tangent vector</strong>. We denote the tangent vector with its tail at the waypoint coordinates and its head at tangent x, y.</p>
<p><img data-src="img/swerve-paths/waypoint.svg" alt="waypoint" /><br />
</p>
</section>
<section id="waypoint-to-trajectory-conversion" class="slide level2">
<h2>Waypoint to Trajectory Conversion</h2>
<p>This <a href="https://github.com/wpilibsuite/PathWeaver/blob/5e8ea0cafca829eeb10aa55ba70542022b6102da/src/main/java/edu/wpi/first/pathweaver/spline/wpilib/WpilibSpline.java#L172">code excerpt</a> from PathWeaver illustrates how it converts a list of waypoints to a trajectory.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="dt">static</span> Trajectory <span class="fu">trajectoryFromWaypoints</span><span class="op">(</span><span class="bu">Iterable</span><span class="op">&lt;</span>Waypoint<span class="op">&gt;</span> waypoints<span class="op">,</span> TrajectoryConfig config<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    var list <span class="op">=</span> <span class="kw">new</span> TrajectoryGenerator<span class="op">.</span><span class="fu">ControlVectorList</span><span class="op">();</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>Waypoint wp<span class="op">:</span> waypoints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        list<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> Spline<span class="op">.</span><span class="fu">ControlVector</span><span class="op">(</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="dt">double</span><span class="op">[]</span> <span class="op">{</span>wp<span class="op">.</span><span class="fu">getX</span><span class="op">(),</span> wp<span class="op">.</span><span class="fu">getTangentX</span><span class="op">(),</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="dt">double</span><span class="op">[]</span> <span class="op">{</span>wp<span class="op">.</span><span class="fu">getY</span><span class="op">(),</span> wp<span class="op">.</span><span class="fu">getTangentY</span><span class="op">(),</span> <span class="dv">0</span><span class="op">}));</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> TrajectoryGenerator<span class="op">.</span><span class="fu">generateTrajectory</span><span class="op">(</span>list<span class="op">,</span> config<span class="op">);</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="but-whats-really-happening">But what’s really happening?</h3>
</section>
<section id="trajectories-are-connected-splines" class="slide level2">
<h2>Trajectories are Connected Splines</h2>
<p>A trajectory is made up of one or more connected <strong>splines</strong>, each defined by end points and the slope at the end points. The end points of each spline are given by two consecutive waypoints from PathWeaver.</p>
<p><img data-src="img/pathweaver/splines_1.svg" style="width:100.0%" alt="splines" /><br />
</p>
</section>
<section class="slide level2">

<p>You can connect together as many splines as you need to complete a trajectory.</p>
<p>Here we show the three splines generated from the four PathWeaver waypoints in our earlier example.</p>
<p><img data-src="img/pathweaver/splines_2.svg" style="width:100.0%" alt="splines" /><br />
</p>
<aside class="notes">
<p>N waypoints will product N-1 splines.</p>
</aside>
</section>
<section id="spline-parameterization" class="slide level2">
<h2>Spline Parameterization</h2>
<p>The <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/spline/SplineParameterizer.html"><code>SplineParameterizer</code></a> (<a href="https://github.com/wpilibsuite/allwpilib/blob/948625de9d40068133adf9b39310055e6521b9c0/wpimath/src/main/java/edu/wpi/first/wpilibj/spline/SplineParameterizer.java">source</a>) class breaks up the spline into various arcs until their dx, dy, and dθ are within specific tolerances.</p>
<p>Each dot on the right plot is a <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/spline/PoseWithCurvature.html"><code>PoseWithCurvature</code></a>.</p>
<p><img data-src="img/pathweaver/spline-parameterized.svg" style="width:100.0%" alt="parameterized spline" /><br />
</p>
<aside class="notes">
<p>This works by checking the whole spline dx, dy and dθ, and then “recursively” splitting spline in half, rechecking each until limits are met.</p>
<p>velocities are planned for these points and constant acceleration/deceleration is assumed between them.</p>
</aside>
</section>
<section class="slide level2">

<p>We calculate the points for each spline and then append them together to produce the <code>PoseWithCurvature</code> points for the entire trajectory.</p>
<p><img data-src="img/pathweaver/splines-parameterized.svg" style="width:100.0%" alt="parameterized splines" /><br />
</p>
<p>At this point, spline parameterization has given us the <strong>x, y</strong> coordinates and the <strong>direction</strong> of travel (<a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/geometry/Pose2d.html"><code>Pose2d</code></a>) for each trajectory point.</p>
</section>
<section id="trajectory-parameterization" class="slide level2">
<h2>Trajectory Parameterization</h2>
<p>After spline parameterization has broken up our trajectory into manageable segments, we next need to calculate the velocity profile.</p>
<p>The velocity profile is, for each trajectory point, the <strong>time</strong> that point is reached, and the <strong>velocity</strong> and <strong>acceleration</strong> at that point. This calculation is called trajectory parameterization.</p>
<p>This is calculated by the <a href="https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj/trajectory/TrajectoryParameterizer.html"><code>TrajectoryParameterizer</code></a> class.</p>
<p><br />
</p>
<p>When you combine this with the <strong>position</strong> and <strong>travel direction</strong> of each trajectory point given by spline parameterization, we have all the information we need for the robot to drive the trajectory. (Spline parameterization also give us <strong>curvature</strong> at each trajectory point.)</p>
</section>
<section class="slide level2">

<p>The <code>TrajectoryParameterizer</code> class calculates the final trajectory points.</p>
<p><br />
</p>
<ol type="1">
<li><p>The distance between trajectory point B and the previous point A is calculated.</p></li>
<li><p>The velocity at B is calculated from the velocity at A, the maximum acceleration, and the distance travelled. <span class="math inline">\(v_B = \sqrt{v_A^2 +2ad}\)</span></p>
<p>Clamp this to the maximum velocity if neccessary.</p></li>
<li><p>Apply trajectory constraints to maximum acceleration and velocity at point B.</p></li>
<li><p>Calculate the actual acceleration from the velocity at A, the constrained velocity at B, and the distance travelled. <span class="math inline">\(a = \frac{v_B^2 - v_A^2}{2d}\)</span></p></li>
<li><p>If actual acceleration exceeds the constrained acceleration for B, assign B’s constrained acceleration to A and loop back to start again.</p></li>
<li><p>If actual acceleration is less than constrained acceleration for B, we are done! Go to next point and repeat.</p></li>
<li><p>When finished in the forward direction, go through this same entire process backwards through the list of points to make sure we don’t exceed maximum decceleration.</p></li>
</ol>
<aside class="notes">
<ul>
<li>We may need to iterate to find the maximum end velocity and common acceleration, since acceleration limits may be a function of velocity.</li>
<li>Enforce global max velocity and max reachable velocity by global acceleration limit.</li>
<li>If the actual acceleration for this state is higher than the max acceleration that we applied, then we need to reduce the max acceleration of the predecessor and try again.</li>
<li>If the actual acceleration is less than the predecessor’s min acceleration, it will be repaired in the backward pass.</li>
</ul>
</aside>
</section>
<section id="parameterized-trajectory-with-centripetal-constraint" class="slide level2">
<h2>Parameterized Trajectory with Centripetal Constraint</h2>
<figure>
<img data-src="img/pathweaver/3d-centripetal.svg" style="width:100.0%" alt="Centripetal constraint limits velocity where there is high curvature." /><figcaption aria-hidden="true">Centripetal constraint limits velocity where there is high curvature.</figcaption>
</figure>
<aside class="notes">
<ul>
<li>we start accelerating at our max acceleration until centripetal acceleration constraints apply.</li>
<li>trajectory is the same going forward as backwards.</li>
</ul>
</aside>
</section>
<section id="curvature" class="slide level2">
<h2>Curvature</h2>
<p>A quick detour into terminology — what is curvature?</p>
<p><img data-src="img/swerve-paths/curvature.svg" style="width:70.0%" alt="curvature" /><br />
</p>
<p>Curvature is primarily uses to <strong>constrain</strong> our trajectory velocity and acceleration profile as needed, for example to prevent the robot from tipping in a tight turn.</p>
<aside class="notes">
<p>Intuitively, the curvature describes for any part of a curve how much the curve direction changes over a small distance travelled, so it is a measure of the instantaneous rate of change of direction of a point that moves on the curve: the larger the curvature, the larger this rate of change. <a href="https://en.wikipedia.org/wiki/Curvature">Wikipedia</a></p>
</aside>
</section></section>
<section id="pathweaver-trajectory-json" class="title-slide slide level1">
<h1>PathWeaver Trajectory JSON</h1>
<p>PathWeaver exports built trajectories in this JSON format. These JSON files are deployed to the robot and loaded into a <code>Trajectory</code> at <code>robotInit()</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">[</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;time&quot;</span><span class="fu">:</span> <span class="fl">0.0</span><span class="fu">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;velocity&quot;</span><span class="fu">:</span> <span class="fl">0.0</span><span class="fu">,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;acceleration&quot;</span><span class="fu">:</span> <span class="fl">2.0</span><span class="fu">,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;pose&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;translation&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;x&quot;</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span> <span class="dt">&quot;y&quot;</span><span class="fu">:</span> <span class="fl">6.21055</span> <span class="fu">},</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;rotation&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;radians&quot;</span><span class="fu">:</span> <span class="fl">0.0</span> <span class="fu">}</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;curvature&quot;</span><span class="fu">:</span> <span class="fl">0.0</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;time&quot;</span><span class="fu">:</span> <span class="fl">0.1759540554030928</span><span class="fu">,</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;velocity&quot;</span><span class="fu">:</span> <span class="fl">0.3519081108061856</span><span class="fu">,</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;acceleration&quot;</span><span class="fu">:</span> <span class="fl">1.9999999999999987</span><span class="fu">,</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;pose&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;translation&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;x&quot;</span><span class="fu">:</span> <span class="fl">1.0309589505195618</span><span class="fu">,</span> <span class="dt">&quot;y&quot;</span><span class="fu">:</span> <span class="fl">6.2103166925191875</span> <span class="fu">},</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;rotation&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;radians&quot;</span><span class="fu">:</span> <span class="fl">-0.02267479979731116</span> <span class="fu">}</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;curvature&quot;</span><span class="fu">:</span> <span class="fl">-1.4861117623228608</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">}</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="ot">]</span></span></code></pre></div>
<p>Each of the JSON objects represents a <code>Trajectory.State</code> object.</p>
</section>
    </div>
  </div>

  <script src="../static/reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="../static/reveal.js/plugin/notes/notes.js"></script>
  <script src="../static/reveal.js/plugin/search/search.js"></script>
  <script src="../static/reveal.js/plugin/zoom/zoom.js"></script>
  <script src="../static/reveal.js/plugin/math/math.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
      
        // Push each slide change to the browser history
        history: true,
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1843.1999999999998,
        height: 1152,
        // Factor of the display size that should remain empty around the content
        margin: 0.08,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
