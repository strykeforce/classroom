<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Stryke Force">
  <title>Swerve Drive</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../static/reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../static/reveal.js/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../static/reveal.js/dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="../static/css/classroom.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide" data-background-color="rgb(241, 186, 27)">
  <h1 class="title">Swerve Drive</h1>
  <p class="author">Stryke Force</p>
</section>

<section>
<section id="swerve-drive-introduction" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Drive Introduction</h1>

</section>
<section id="mechanical-design" class="slide level2">
<h2>Mechanical Design</h2>
<ul>
<li>Motors &amp; Controllers</li>
<li>Drive</li>
<li>Azimuth - turns</li>
</ul>
<p>Put a picture here.</p>
</section>
<section id="swerve-operation" class="slide level2">
<h2>Swerve Operation</h2>
<ul>
<li>Forward / Back</li>
<li>Strafe Left / Right</li>
</ul>
</section>
<section id="swerve-control-systems" class="slide level2">
<h2>Swerve Control Systems</h2>
<ul>
<li>Azimuth closed-loop</li>
<li>Drive open-loop</li>
<li>Drive closed-loop</li>
</ul>
</section></section>
<section>
<section id="swerve-drive-motion" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Drive Motion</h1>
<p>To move the swerve drive, we need to convert the desired motion of the robot into positions and speeds of each of the four swerve wheels.</p>
</section>
<section id="swerve-motion" class="slide level2">
<h2>Swerve Motion</h2>
<p>There are three components to swerve drive motion.</p>
<ul>
<li><strong>Forward</strong> and backwards</li>
<li><strong>Strafe</strong> left and right</li>
<li><strong>Yaw</strong> counter-clockwise and clockwise</li>
</ul>
<p><img data-src="img/swerve-math/directions.svg" alt="swerve directions" /><br />
</p>
<p>The red arrows indicate the <strong>speed</strong> and <strong>direction</strong> each wheel is pushing.</p>
<p>We call this the <strong>velocity vector</strong> of the wheel.</p>
</section>
<section id="swerve-motion-1" class="slide level2">
<h2>Swerve Motion</h2>
<p>These separate components can be combined together to move the robot in any direction.</p>
<p><img data-src="img/swerve-math/forward+strafe.svg" alt="forward+strafe" /><br />
</p>
<p>In this example, equal amounts of <strong>forward</strong> and <strong>strafe</strong> input drive the robot at 45° across the field.</p>
</section>
<section id="swerve-motion-2" class="slide level2">
<h2>Swerve Motion</h2>
<p>All three components can be combined together to produce complex motion.</p>
<p><img data-src="img/swerve-math/forward+strafe+yaw.svg" alt="forward+strafe" /><br />
</p>
<p>In this example, equal amounts of <strong>forward</strong>, <strong>strafe</strong> and <strong>yaw</strong> input drive the robot across the field while yawing.</p>
</section>
<section id="swerve-yaw-component" class="slide level2">
<h2>Swerve Yaw Component</h2>
<p>When the robot yaws, the wheels are positioned perpendicular to the center of rotation.</p>
<p>Note that this is not 45° if the robot isn’t square.</p>
<p><img data-src="img/swerve-math/frame-aspect.svg" alt="frame aspect ration" /><br />
</p>
<p>We can also yaw around an arbitrary off-center point relative to the robot.</p>
</section></section>
<section>
<section id="swerve-math" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Math</h1>
<p>We can calculate desired position and speed of each wheel using vectors.</p>
</section>
<section id="vectors" class="slide level2">
<h2>Vectors</h2>
<p>We use <strong>vectors</strong> to represent velocity, which is speed and direction.</p>
<p><img data-src="img/swerve-math/vectors.svg" alt="vectors" /><br />
</p>
<p>Here we show how to add two vectors together, later we will show rotating a vector by a given angle.</p>
</section>
<section id="coordinate-frames" class="slide level2">
<h2>Coordinate Frames</h2>
<p>We work in two coordinate frames, one local to the robot and one global for the field.</p>
<p>Going forward, we’ll also refer to swerve drive motion components (forward, strafe, yaw) as chassis speed (<strong>v<sub>x</sub></strong>, <strong>v<sub>y</sub></strong>, and <strong>ω</strong>), with respect to the robot frame of reference.</p>
<p><img data-src="img/swerve-math/coordinate-frames.svg" alt="coordinate frames" /><br />
</p>
</section>
<section id="wheel-position-and-speed" class="slide level2">
<h2>Wheel Position and Speed</h2>
<p>We add together the desired robot-oriented velocity inputs to get a velocity vector for each wheel.</p>
<p><img data-src="img/swerve-math/wheel-vectors.svg" alt="coordinate frames" /><br />
</p>
</section>
<section id="wheel-speed-and-azimuth" class="slide level2">
<h2>Wheel Speed and Azimuth</h2>
<p>Each wheel’s <strong>speed</strong> and <strong>azimuth</strong> can be calculated from its velocity vector (<strong>v</strong><sub>w</sub>).</p>
<p><img data-src="img/swerve-math/wheel-position+speed.svg" alt="wheel position + speed" /><br />
</p>
<p><strong>Azimuth</strong> (θ) is the term we use for the wheel’s angle relative to the robot frame of reference.</p>
</section>
<section id="normalize-wheel-speeds" class="slide level2">
<h2>Normalize Wheel Speeds</h2>
<p>Sometimes after calculating wheel velocity vectors, the requested speed may be above the maximum attainable speed for the drive motor on that swerve module.</p>
<p>To fix this issue, we “normalize” all the wheel speeds to make sure that all requested module speeds are below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<p><br />
</p>
<table>
<thead>
<tr class="header">
<th>Wheel</th>
<th style="text-align: right;">Calculated Speed</th>
<th style="text-align: right;">Normalized Speed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LF</td>
<td style="text-align: right;">2.414</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td>RF</td>
<td style="text-align: right;">1.732</td>
<td style="text-align: right;">0.717</td>
</tr>
<tr class="odd">
<td>LR</td>
<td style="text-align: right;">1.732</td>
<td style="text-align: right;">0.717</td>
</tr>
<tr class="even">
<td>RR</td>
<td style="text-align: right;">0.414</td>
<td style="text-align: right;">0.172</td>
</tr>
</tbody>
</table>
</section>
<section id="optimize-wheel-position" class="slide level2">
<h2>Optimize Wheel Position</h2>
<p>We minimize the change in heading the desired swerve wheel direction would require by potentially reversing the direction the wheel spins.</p>
<p>When optimized, the furthest a wheel will ever rotate is 90 degrees.</p>
<div class="columns">
<div class="column" style="display:inline-flex; flex-direction: column; justify-content: center; height: 766px">
<p>If the difference between your desired and current azimuth is greater than 90°, rotate the desired azimuth by 180° and reverse the drive motor.</p>
</div><div class="column" style="width:50%;">
<p><img data-src="img/swerve-math/optimized-azimuth.svg" alt="optimize azimuth" /><br />
</p>
</div>
</div>
</section>
<section id="field-oriented-driving" class="slide level2">
<h2>Field Oriented Driving</h2>
<p>In Teleoperation, we normally provide driver joystick (velocity) inputs relative to the field frame of reference.</p>
<p>We rotate the requested field-oriented robot velocity vector by an amount equal to the gyro angle, θ, to get the desired robot-oriented velocity vector.</p>
<p><img data-src="img/swerve-math/field-oriented.svg" alt="optimize azimuth" /><br />
</p>
<p>In this example, pushing the <strong>v</strong><sub>x</sub> (F/R) joystick in the postive x direction will move the robot directly down the field, no matter the direction the robot is facing (θ).</p>
</section></section>
<section>
<section id="swerve-software" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Swerve Software</h1>
<p>In our robot, we use the WPILIB kinematics suite to convert<br />
desired velocities to swerve module speed and angle.</p>
</section>
<section id="terminology" class="slide level2">
<h2>Terminology</h2>
<dl>
<dt>Kinematics</dt>
<dd><p>The kinematics classes help convert between a universal <code>ChassisSpeeds</code> object, containing linear and angular velocities for a robot to usable speeds for each individual module states (speed and angle) for a swerve drive.</p>
</dd>
<dt>Odometry</dt>
<dd><p>Odometry uses sensors on the robot to create an estimate of the position of the robot on the field. In our robots, these sensors are typically drive and azimuth encoders and a gyroscope to measure robot angle.</p>
</dd>
<dd><p>The odometry classes utilize the kinematics classes along with periodic inputs about speeds and angles to create an estimate of the robot’s location on the field.</p>
</dd>
<dt>Pose</dt>
<dd><p>A robot’s pose is the combination of it’s X, Y, and angle (θ) with respect to the field.</p>
</dd>
</dl>
</section>
<section id="the-chassisspeeds-class" class="slide level2">
<h2>the <code>ChassisSpeeds</code> Class</h2>
<p>The <code>ChassisSpeeds</code> class represents the speeds of a robot chassis.</p>
<dl>
<dt><code>vx</code></dt>
<dd>The velocity of the robot in the <strong>x</strong> (forward) direction.
</dd>
<dt><code>vy</code></dt>
<dd>The velocity of the robot in the <strong>y</strong> (strafe) direction.<br />
Positive values mean the robot is moving to the left.
</dd>
<dt><code>omega</code></dt>
<dd>The angular velocity of the robot in radians per second.<br />
Positive is CCW rotation (yaw) of the robot.
</dd>
</dl>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> xSpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ySpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> rotSpeed <span class="op">=</span> rightJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxRadiansPerSec<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">);</span></span></code></pre></div>
<p>Speeds are aligned to a <a href="#/coordinate-frames">coordinate system</a> and are given in meters per second.</p>
</section>
<section class="slide level2">

<p>We also use the <code>ChassisSpeeds</code> to convert <a href="#/field-oriented-driving">field-relative</a> speeds into robot-relative speeds.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> xSpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ySpeed <span class="op">=</span> leftJoystick<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> kMaxMetersPerSec<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> rotSpeed <span class="op">=</span> rightJoystick<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> kMaxRadiansPerSec<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> ChassisSpeeds<span class="op">.</span><span class="fu">fromFieldRelativeSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">,</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">());</span></span></code></pre></div>
<p>The angle of the robot is measured by a gyroscope. The robot’s angle is considered to be zero when it is facing directly away from our alliance station wall.</p>
</section>
<section id="the-swervedrivekinematics-class" class="slide level2">
<h2>The <code>SwerveDriveKinematics</code> Class</h2>
<p>The <code>SwerveDriveKinematics</code> class is a helper class that converts a chassis velocity (<strong>v</strong><sub>x</sub>, <strong>v</strong><sub>y</sub>, and <strong>ω</strong> components) into individual module states (speed and angle).</p>
<p>We initialize an instance of this class by passing in four wheel locations, in meters, relative to the center of the robot.</p>
<div class="columns">
<div class="column" style="width:75%;">
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>var frontLeft <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>var frontRight <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>var rearLeft <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(-</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>var rearRight <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(-</span><span class="fl">0.3</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>var kinematics <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveKinematics</span><span class="op">(</span>frontLeft<span class="op">,</span> frontRight<span class="op">,</span> rearLeft<span class="op">,</span> rearRight<span class="op">);</span></span></code></pre></div>
</div><div class="column" style="width:25%;">
<p><img data-src="img/swerve-software/wheel-locations.svg" style="width:65.0%" alt="wheel locations" /><br />
</p>
</div>
</div>
</section>
<section class="slide level2">

<p>We then use this <code>kinematics</code> instance to perform <em>inverse kinematics</em> to return the module states from a desired chassis velocity.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>var speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span>xSpeed<span class="op">,</span> ySpeed<span class="op">,</span> rotSpeed<span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">);</span></span></code></pre></div>
<p>The returned module states are an array of four <code>SwerveModuleState</code> objects, each containing the speed and angle of one of the wheels. They are passed back in the same wheel order that we initialized the <code>SwerveDriveKinematics</code> in.</p>
<p><br />
</p>
<p>If you want to specify a <a href="#/swerve-yaw-component">variable center of rotation</a> for the robot, you can pass in a optional <code>Translation2d</code> object that is the desired center.</p>
<p>For example, you want to yaw the robot underneath the shooter that is 10 cm left of the centerline of the robot.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>var speeds <span class="op">=</span> <span class="kw">new</span> <span class="fu">ChassisSpeeds</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> rotSpeed<span class="op">);</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>var center <span class="op">=</span> <span class="kw">new</span> <span class="fu">Translation2d</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span></code></pre></div>
</section>
<section class="slide level2">

<p>Sometimes after calculating wheel velocity vectors, the requested speed may be above the maximum attainable speed for the swerve module drive motor and need to be <a href="#/normalize-wheel-speeds">normalized</a>.</p>
<p>To fix this issue, <code>SwerveDriveKinematics</code> has a <code>normalizeWheelSpeeds​</code> static method.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>SwerveDriveKinematics<span class="op">.</span><span class="fu">normalizeWheelSpeeds</span><span class="op">(</span>states<span class="op">,</span> kMaxMetersPerSec<span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">// all state speeds are now less than or equal to kMaxMetersPerSec...</span></span></code></pre></div>
<p>We can also use this <code>kinematics</code> instance to perform <em>foward kinematics</em> to return the instantaneous chassis velocity from module states.</p>
<p>Typically we would query the hardware encoders to get actual module states, as in this example.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// driveSubsystem has code to read swerve module hardware encoders and converts to module states</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> driveSubsystem<span class="op">.</span><span class="fu">getModuleStates</span><span class="op">();</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ChassisSpeeds speeds <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toChassisSpeeds</span><span class="op">(</span>states<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;robot vxMetersPerSecond = </span><span class="sc">%f</span><span class="st">, vyMetersPerSecond = </span><span class="sc">%f</span><span class="st">, omegaRadiansPerSecond = </span><span class="sc">%f</span><span class="st"> </span><span class="sc">%n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">vxMetersPerSecond</span><span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">vyMetersPerSecond</span><span class="op">,</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    speeds<span class="op">.</span><span class="fu">omegaRadiansPerSecond</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
</section>
<section id="the-swervemodulestate-class" class="slide level2">
<h2>The <code>SwerveModuleState</code> Class</h2>
<p>The <code>SwerveModuleState</code> is a simple data class that represents the speed and direction of a swerve module.</p>
<p>We would typically pass it to our own <code>SwerveModule</code> class that knows about our specific hardware.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> kinematics<span class="op">.</span><span class="fu">toSwerveModuleStates</span><span class="op">(</span>speeds<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> SwerveDriveKinematics<span class="op">.</span><span class="fu">normalizeWheelSpeeds</span><span class="op">(</span>states<span class="op">,</span> kMaxMetersPerSec<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>frontLeftModule<span class="op">.</span><span class="fu">setDesiredState</span><span class="op">(</span>states<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">// rest of modules...</span></span></code></pre></div>
<p>It also performs the <a href="#/optimize-wheel-position">optimization of wheel positioning</a> by minimizing the change in heading the desired swerve wheel direction would require by potentially reversing the direction the wheel spins. For example, our <code>SwerveModule</code> class could use it in its <code>setDesiredState</code> method.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">setDesiredState</span><span class="op">(</span>SwerveModuleState desiredState<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    SwerveModuleState state <span class="op">=</span> SwerveModuleState<span class="op">.</span><span class="fu">optimize</span><span class="op">(</span>desiredState<span class="op">,</span> <span class="kw">new</span> <span class="fu">Rotation2d</span><span class="op">(</span>azimuth<span class="op">.</span><span class="fu">getEncoderValue</span><span class="op">()));</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use optimized state to set module speed and angle...</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="the-swervedriveodometry-class" class="slide level2">
<h2>The <code>SwerveDriveOdometry</code> Class</h2>
<p>Odometry allows us to track our robot’s position on the field over a course of a match using readings from swerve drive encoders and swerve azimuth encoders.</p>
<p>We initialize an instance of this class by passing in our initialized <code>SwerveDriveKinimatics</code> object, the robot’s gyro angle, and optionally a starting robot pose.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>var kinematics <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveKinematics</span><span class="op">(</span>frontLeft<span class="op">,</span> frontRight<span class="op">,</span> rearLeft<span class="op">,</span> rearRight<span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>var theta <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>var odometry <span class="op">=</span> <span class="kw">new</span> <span class="fu">SwerveDriveOdometry</span><span class="op">(</span>kinematics<span class="op">,</span> theta<span class="op">);</span></span></code></pre></div>
<p>Periodically (for example, in <code>Subsystem.periodic()</code>), we update the odometry with the current gyro angle and swerve module states.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">periodic</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    var theta <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    SwerveModuleState<span class="op">[]</span> states <span class="op">=</span> <span class="fu">getModuleStates</span><span class="op">();</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    odometry<span class="op">.</span><span class="fu">update</span><span class="op">(</span>theta<span class="op">,</span> states<span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section class="slide level2">

<p>We can perform a “hard” reset of the odometry position if we are in possession of a known robot position. For example, perhaps we have just driven the robot into some sort of game feature like a docking port.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Pose2d pose <span class="op">=</span> Constants<span class="op">.</span><span class="fu">DOCKING_POSE</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>var gyroAngle <span class="op">=</span> gyro<span class="op">.</span><span class="fu">getRotation2d</span><span class="op">();</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>odometry<span class="op">.</span><span class="fu">resetPosition</span><span class="op">(</span>pose<span class="op">,</span> gyroAngle<span class="op">);</span></span></code></pre></div>
<p>By passing in the gyro angle, odometry will compensate for any gyro drift that has occurred up to this point.</p>
<p><br />
</p>
<p>Finally, we can ask odometry for the robot’s calculated field position and angle. This returns the pose of the robot as of the last call to <code>update()</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Pose2d pose <span class="op">=</span> odometry<span class="op">.</span><span class="fu">getPoseMeters</span><span class="op">();</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;robot x = </span><span class="sc">%f</span><span class="st"> meters, y = </span><span class="sc">%f</span><span class="st"> meters, theta = </span><span class="sc">%f</span><span class="st"> degrees </span><span class="sc">%n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getX</span><span class="op">(),</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getY</span><span class="op">(),</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    pose<span class="op">.</span><span class="fu">getRotation</span><span class="op">().</span><span class="fu">getDegrees</span><span class="op">()</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>We can use odometry during the autonomous period for complex tasks like path following. Furthermore, odometry can be used for latency compensation when using computer-vision systems.</p>
</section>
<section id="swerve-kinematics-examples" class="slide level2">
<h2>Swerve Kinematics Examples</h2>
<p>We can use the Python version of WPILIB kinematics classes in a Jupyter notebook to easily convert desired robot speed and rotation into swerve wheel speeds and angles.</p>
<p>The classes and concepts are identical to the Java version we use on the robot.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># define some useful constants</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>MAX_SPEED <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>MAX_ROTATION <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> math.pi</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># set up the swerve drive kinematics class by specifying where the wheels are</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># relative to the center of the robot</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fl_loc <span class="op">=</span> Translation2d(<span class="fl">0.3</span>, <span class="fl">0.3</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fr_loc <span class="op">=</span> Translation2d(<span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.3</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>rl_loc <span class="op">=</span> Translation2d(<span class="op">-</span><span class="fl">0.3</span>, <span class="fl">0.3</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>rr_loc <span class="op">=</span> Translation2d(<span class="op">-</span><span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.3</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>kinematics <span class="op">=</span> SwerveDrive4Kinematics(fl_loc, fr_loc, rl_loc, rr_loc)</span></code></pre></div>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-direction">Drive in forward direction</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-01.svg" style="width:60.0%" alt="swerve 01" /><br />
</p>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-right-directions">Drive in forward, right directions</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="op">-</span>MAX_SPEED, <span class="dv">0</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-02.svg" style="width:60.0%" alt="swerve 02" /><br />
</p>
</section>
<section class="slide level2">

<h3 id="drive-in-forward-right-and-clockwise-directions">Drive in forward, right and clockwise directions</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>speeds <span class="op">=</span> ChassisSpeeds(MAX_SPEED, <span class="op">-</span>MAX_SPEED, <span class="op">-</span>MAX_ROTATION)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.toSwerveModuleStates(speeds)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>module_states <span class="op">=</span> kinematics.normalizeWheelSpeeds(module_states, MAX_SPEED)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plot_swerve(wheel_locs, module_states)</span></code></pre></div>
<p><img data-src="img/swerve-software/swerve-03.svg" style="width:60.0%" alt="swerve 03" /><br />
</p>
</section></section>
<section>
<section id="trajectory-following" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Trajectory Following</h1>
<p>Move from a known starting location to a known scoring location.</p>
</section>
<section id="why-trajectory-following" class="slide level2">
<h2>Why Trajectory Following?</h2>
<p>FRC® games often feature autonomous tasks that require a robot to effectively and accurately move from a known starting location to a known scoring location.</p>
<p><img data-src="img/swerve-paths/why-trajectory.svg" alt="why trajectory" /><br />
</p>
<p>While more technically challenging, trajectories can be driven much faster since we don’t have to stop to change direction.</p>
</section>
<section id="wpilib" class="slide level2">
<h2>WPILIB</h2>
</section></section>
<section id="appendix" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">Appendix</h1>

</section>

<section>
<section id="pathweaver-deep-dive" class="title-slide slide level1" data-background-color="rgb(241, 186, 27)">
<h1 data-background-color="rgb(241, 186, 27)">PathWeaver Deep Dive</h1>
<p>A survey of how PathWeaver interfaces with WPILIB Trajectory classes.</p>
</section>
<section id="pathweaver-path" class="slide level2">
<h2>PathWeaver Path</h2>
<p>We can use PathWeaver to create a trajectory for the robot to drive.</p>
<p><br />
</p>
<p><img data-src="img/pathweaver/pathweaver_screenshot.png" alt="pathweaver screenshot" /><br />
</p>
</section>
<section id="pathweaver-path-1" class="slide level2">
<h2>PathWeaver Path</h2>
<p>PathwWaver internally represents this path as a list of <strong>waypoints</strong>.</p>
<p><br />
</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">X</th>
<th style="text-align: right;">Y</th>
<th style="text-align: right;">Tangent X</th>
<th style="text-align: right;">Tangent Y</th>
<th style="text-align: center;">Fixed Theta</th>
<th style="text-align: center;">Reversed</th>
<th style="text-align: left;">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">-2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">start</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">top internal</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">-3</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">false</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">bottom internal</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">-2</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: center;">true</td>
<td style="text-align: center;">false</td>
<td style="text-align: left;">end</td>
</tr>
</tbody>
</table>
<p><br />
</p>
<p>They are saved as CSV-formatted data in <code>*.path</code> files in a PathWeaver project.</p>
</section>
<section id="pathweaver-waypoints" class="slide level2">
<h2>PathWeaver Waypoints</h2>
<p>The important parts of a waypoint are its coordinates and the length and direction of its <strong>tangent vector</strong>. We denote the tangent vector with its tail at the waypoint coordinates and its head at tangent x, y.</p>
<p><img data-src="img/swerve-paths/waypoint.svg" alt="waypoint" /><br />
</p>
</section>
<section id="trajectories-are-splines" class="slide level2">
<h2>Trajectories are Splines</h2>
<p>A trajectory is made up of one or more connected <strong>splines</strong>, each defined by end points and the slope at the end points. The end points of each spline are given by two consecutive waypoints from PathWeaver.</p>
<p><img data-src="img/pathweaver/splines_1.svg" style="width:100.0%" alt="splines" /><br />
</p>
</section>
<section class="slide level2">

<p>Here we show the three splines generated from PathWeaver waypoints in our first example.</p>
<p><img data-src="img/pathweaver/splines_2.svg" style="width:100.0%" alt="splines" /><br />
</p>
</section>
<section id="waypoint-to-trajectory-conversion" class="slide level2">
<h2>Waypoint to Trajectory Conversion</h2>
<p>This <a href="https://github.com/wpilibsuite/PathWeaver/blob/5e8ea0cafca829eeb10aa55ba70542022b6102da/src/main/java/edu/wpi/first/pathweaver/spline/wpilib/WpilibSpline.java#L172">code excerpt</a> from PathWeaver illustrates how it converts a list of waypoints to a list of spline control vectors and uses these splines to generate a trajectory.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="dt">static</span> Trajectory <span class="fu">trajectoryFromWaypoints</span><span class="op">(</span><span class="bu">Iterable</span><span class="op">&lt;</span>Waypoint<span class="op">&gt;</span> waypoints<span class="op">,</span> TrajectoryConfig config<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    var list <span class="op">=</span> <span class="kw">new</span> TrajectoryGenerator<span class="op">.</span><span class="fu">ControlVectorList</span><span class="op">();</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>Waypoint wp<span class="op">:</span> waypoints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        list<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> Spline<span class="op">.</span><span class="fu">ControlVector</span><span class="op">(</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="dt">double</span><span class="op">[]</span> <span class="op">{</span>wp<span class="op">.</span><span class="fu">getX</span><span class="op">(),</span> wp<span class="op">.</span><span class="fu">getTangentX</span><span class="op">(),</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="dt">double</span><span class="op">[]</span> <span class="op">{</span>wp<span class="op">.</span><span class="fu">getY</span><span class="op">(),</span> wp<span class="op">.</span><span class="fu">getTangentY</span><span class="op">(),</span> <span class="dv">0</span><span class="op">}));</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> TrajectoryGenerator<span class="op">.</span><span class="fu">generateTrajectory</span><span class="op">(</span>list<span class="op">,</span> config<span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section></section>
    </div>
  </div>

  <script src="../static/reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="../static/reveal.js/plugin/notes/notes.js"></script>
  <script src="../static/reveal.js/plugin/search/search.js"></script>
  <script src="../static/reveal.js/plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
      
        // Push each slide change to the browser history
        history: true,
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1843.1999999999998,
        height: 1152,
        // Factor of the display size that should remain empty around the content
        margin: 0.08,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
